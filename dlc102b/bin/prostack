#!/bin/sh
# Set PROGram name
PROG=`basename $0`
########################################################################
#+ NAME
#+      "prostack" prompts you to select an option which best
#+	describes your OS and machine.  "prostack" then uses the
#+	information to determine which debuggers are available
#+	for your machine.  For each debugger available on your
#+	machine, "prostack" can be used to produce a stack
#+	trace from either an existing core file for from a 
#+	running image.
#+ 
#+ SYNOPSIS
#+     prostack -r ImageFile CoreFile
#+		or
#+     prostack -a Pid ImageFile
#+		or
#+     prostack -t
#+ 
#+ DESCRIPTION
#+     -r  Read to the given core file and produce a stack trace. 
#+
#+     -a  Attach to the given running process and produce a 
#+	   stack trace. 
#+
#+     -t  Test option.  For each debugger available on an OS release, 
#+	   "prostack" runs three tests:
#+
#+		test #1	forces the _progres command, defined by
#+			environmental variable PROEXE, to produce
#+			a core file.  The test then attempts to
#+			obtain a stack trace from the core file.
#+
#+		test #2	forces $PROEXE to loop.  The test then
#+			attempts to attach to the looping process
#+			running to obtain a stack trace.
#+
#+		test #3	forces the looping $PROEXE process, started
#+			in test #2, to dump core by sending the process
#+			a floating point exception signal (kill -8).  The
#+			test then attempts to obtain a stack trace against
#+			the core file produced.
#+
#+ OUTPUT
#+      For each debugger available on a given OS,
#+	a "<debugger-name><test-num>.log" file is created or appended to
#+	("test-num" is part of the log name only when the -t option is 
#+	specified).  This log file contains the date, debugger commands 
#+	exercised, and the stack trace produced by the debugger commands 
#+	listed.
#+
#+ OPTIONS
#+ 
#+ EXAMPLES
#+
#+	To obtain a stack trace by attaching to a process called
#+	/usr1/dlc/bin/_progres, running at pid location 3304, do:
#+
#+	      $	prostack -a 3304 /usr1/dlc/bin/_progres
#+
#+	To obtain a stack trace from a core file, located at
#+	/usr/users/jones/core, and generated by process 
#+	/usr1/dlc/bin/_progres, do:
#+
#+	      $	prostack -r /usr1/dlc/bin/_progres /usr/users/jones/core
#+
#+	In both example cases:
#+	    1.  The user is prompted to select an option
#+		which best describes the OS and machine that the
#+		user is logged into.
#+	    2.  The user is prompted to confirm the selected option.
#+		If the user does not confirm the selected option, 
#+		"prostack" will prompt the user again with the
#+		original OS / machine selection list.
#+	    3.  Log messages are displayed on the screen which
#+		indicate what actions "prostack" is working on.
#+	    4.  The stack trace output is appended to the
#+		<debugger-name>.log file in the user's working directory.
#+		The log file is created if it does not already exist.
#+ 
#+ FILES
#+ 
#+ SEE ALSO
#+     cc	    -  see "cc" man page for a list of debuggers available
#+		       on a specific platform.
#+ 
#+ BUGS
#+ 
#- AUTHOR & DT : henning Wed Aug 30 16:03:00 EDT 1995
#- RCS VERS $Id: prostack,v 1.6 97/05/08 11:42:55 meleedy Exp $
#- MOD DATE, BY:
#- MOD DESCRIPT:
#-
########################################################################

USAGE="usage: prostack { -r | -a Pid } ImageFile [ CoreFile ]"

if echo "\c" | grep c >/dev/null 2>&1
then
  N='-n'
  C=''
else
  N=''
  C='\c'
fi

#
# Set up defaults
#
ACTION="read"
CORE="core"

#
# Process the line options
#
set -- `getopt "a:rt" $@`
if [ $? != 0 ] 
then
    echo "$USAGE"
    exit 1
fi

unset PROCID
for ARGS
do
    case "${ARGS}" in
	    -r) ACTION="read"
		;;
	    -a) ACTION="attach"
		PROCID=$2
		;;
	    -t) ACTION="test"
		IMAGEFILE=${PROEXE-_progres}
		;;
	    --) break
		;;
    esac
    shift
done
shift

if [ x"${ACTION}" != x"test" ] 
then
    if [ $# -lt 1 ]
    then
	#
	# At least two arguments must be supplied.
	#
	echo ${USAGE}
	exit 1
    fi
    IMAGEFILE=$1

    if [ $# -eq 2 ]
    then
	CORE=$2		# override default
    fi
fi

#
# Verify that user supplied arguments are okay.
#
if [ ! -s ${IMAGEFILE} ]
then
    echo ${USAGE}
    echo "Image file '${IMAGEFILE}' not found."
    exit 1
fi
if [ x"${ACTION}" = x"read" ] && [ ! -s ${CORE} ]
then
    echo ${USAGE}
    echo "Core file '${CORE}' not found."
    exit 1
fi

#
# Global vars
#
OADB="adb"; 		ADB="adb"
ODBX="dbx"; 		DBX="dbx"
ODBXTRA="dbxtra"; 	DBXTRA="dbxtra"
ODEBUG="debug"; 	DEBUG="debug"
OMXDB="mxdb"; 		MXDB="mxdb"
OSDB="sdb"; 		SDB="sdb"
OXDB="xdb"; 		XDB="xdb"
OGDB="gdb";		GDB="gdb"
SLEEPTIME=5
DEBUGERROR="debugger not found"
NODEBUGGER="No debuggers found on system!"
BDELIMITER="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
SDELIMITER="		=============================================="

read_stack ()
{
    DEBUGGER="$1"
    if [ x"${ACTION}" = x"test" ]
    then
	TESTNUM=$2
    else
	unset TESTNUM
    fi
    DEBUGLOG="`basename ${DEBUGGER}`${TESTNUM}.log"
    SCRIPT="`basename ${DEBUGGER}`.script"

    #
    # Read stack trace.
    #
    echo "Appending output to file ${DEBUGLOG}..."

    (
      echo ""
      echo "Date:  `date`"
      echo ""
      case ${DEBUGGER} in
	"${ADB}" )
	    echo "${ADB} ${IMAGEFILE} ${CORE} << END_OF_INPUT" > ${SCRIPT}
	    echo "\\\$c" >> ${SCRIPT}
	    echo "\\\$q" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${DBX}" )
	    echo "${DBX} ${IMAGEFILE} ${CORE} << END_OF_INPUT" > ${SCRIPT}
	    if [ x"${MACHINE}" = x"SGI" ]
	    then
		echo "set \\\$page = 0" >> ${SCRIPT}
	    fi
	    echo "where" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${SDB}" )
	    echo "${SDB} ${IMAGEFILE} ${CORE} << END_OF_INPUT" > ${SCRIPT}
	    echo "t" >> ${SCRIPT}
	    echo "q" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${XDB}" )
	    echo "${XDB} -L ${IMAGEFILE} ${CORE} << END_OF_INPUT" > ${SCRIPT}
	    echo "n" >> ${SCRIPT}
	    echo "trace" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "y" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${DBXTRA}" )
	    echo "${DBXTRA} -s ${IMAGEFILE} ${CORE} << END_OF_INPUT" > ${SCRIPT}
	    echo "where" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${DEBUG}" )
	    echo "${DEBUG} -c ${CORE} ${IMAGEFILE} << END_OF_INPUT" > ${SCRIPT}
	    echo "stack" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${MXDB}" )
	    echo "${MXDB} -c ${CORE} ${IMAGEFILE} << END_OF_INPUT" > ${SCRIPT}
	    echo "walkback" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${PDBX}" )

		    echo "${PDBX} ${IMAGEFILE} ${CORE} << END_OF_INPUT" > ${SCRIPT}
	    echo "t" >> ${SCRIPT}
	    echo "q" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${GDB}" )
	    echo "${GDB} -c ${CORE} ${IMAGEFILE} << END_OF_INPUT" > ${SCRIPT}	   
	    echo "bt" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	* )
	    rm -f ${SCRIPT}
	    echo "UNKNOWN debugger ${DEBUGGER}"
	    ;;
    esac

    #
    # Run the script.
    #
    echo "Debugger commands:"
    echo ""
    cat ${SCRIPT}
    echo ""
    echo "Stack trace:"
    echo ""
    sh ${SCRIPT} | tee ${SCRIPT}.tmp
    echo ""
    echo ${BDELIMITER}
    rm -f ${SCRIPT}

    ) >> ${DEBUGLOG} 2>&1

    if [ x"${ACTION}" = x"test" ]
    then
	result=1
	if [ -f ${SCRIPT}.tmp ]
	then
	    grep "main" ${SCRIPT}.tmp > /dev/null
	    result=$?
	    rm -f ${SCRIPT}.tmp
	fi

	if [ ${result} = 0 ]
	then
	    echo "Debugger ${DEBUGGER} test #${TESTNUM} SUCCEEDED"
	else
	    echo "Debugger ${DEBUGGER} test #${TESTNUM} FAILED"
	fi
    fi
}

attach_stack ()
{
    DEBUGGER="$1"
    PROCID="$2"
    if [ x"${ACTION}" = x"test" ]
    then
	TESTNUM="$3"
    else
	unset TESTNUM
    fi
    DEBUGLOG="`basename ${DEBUGGER}`${TESTNUM}.log"
    debugger=`basename ${DEBUGGER}`
    SCRIPT="`basename ${DEBUGGER}`.script"

    #
    # Attach to ${PROCID} and generate a stack trace.
    #
    echo "Appending output to file ${DEBUGLOG}..."
    echo ""

    (
    echo ""
    echo "Date:  `date`"
    echo ""

    nodebugger="true"
    case ${MACHINE} in
    "Tru64" )
	case ${DEBUGGER} in
	"${DBX}" )
	    echo ""
	    echo "	NOTE:	This command should be run as root."
	    echo ""
	    nodebugger="false"
	    echo "${DBX} -pid ${PROCID} ${IMAGEFILE} << END_OF_INPUT" > ${SCRIPT}
	    echo "where" >> ${SCRIPT}
	    echo "detach" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
        esac
	;;
    "HPUX" )
	case ${DEBUGGER} in
	"${XDB}" )
            echo ""
            echo "   NOTE:  PROEXE must point to an executable that exists on a"
            echo "          local filesystem in order to attach to a running "
            echo "          process."
            echo ""
	    nodebugger="false"
	    echo "${XDB} -P ${PROCID} -L ${IMAGEFILE} << END_OF_INPUT" > ${SCRIPT}
	    echo "trace" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "y" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${ADB}" )
            echo ""
            echo "   NOTE:  PROEXE must point to an executable that exists on a"
            echo "          local filesystem in order to attach to a running "
            echo "          process."
            echo ""
	    nodebugger="false"
	    echo "${ADB} -P${PROCID} ${IMAGEFILE} << END_OF_INPUT" > ${SCRIPT}
	    echo "\\\$c" >> ${SCRIPT}
	    echo "\\\$q" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
        esac
	;;
    "AIX" )
	case ${DEBUGGER} in
	"${DBX}" )
	    nodebugger="false"
	    echo "${DBX} -a ${PROCID} << END_OF_INPUT" > ${SCRIPT}
	    echo "where" >> ${SCRIPT}
	    echo "detach" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
        esac
	;;
    "SCO" )
	case ${DEBUGGER} in
	"${DBXTRA}" )
	    echo ""
	    echo "	NOTE:	You must be root in order to attach"
	    echo "		to a running process with this debugger"
	    echo "		sequence."
	    echo ""
	    nodebugger="false"
	    echo "${DBXTRA} -s ${IMAGEFILE} ${PROCID} << END_OF_INPUT" > ${SCRIPT}
	    echo "where" >> ${SCRIPT}
	    echo "detach" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
        esac
	;;
    "SunOS" )
	case ${DEBUGGER} in
	"${DBX}" )
	    nodebugger="false"
	    echo "${DBX} ${IMAGEFILE} ${PROCID} << END_OF_INPUT" > ${SCRIPT}
	    echo "where" >> ${SCRIPT}
	    echo "detach" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${ADB}" )
	    nodebugger="false"
	    echo "${ADB} ${IMAGEFILE} << END_OF_INPUT" > ${SCRIPT}
	    echo "0t${PROCID}:A" >> ${SCRIPT}
	    echo "\\\$c" >> ${SCRIPT}
	    echo ":R" >> ${SCRIPT}
	    echo "\\\$q" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
        esac
	;;
    "SVR4_DGUX" )
	case ${DEBUGGER} in
	"${DBX}" )
	    nodebugger="false"
	    echo "${DBX} << END_OF_INPUT" > ${SCRIPT}
	    echo "debug ${IMAGEFILE} ${PROCID}" >> ${SCRIPT}
	    echo "where" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
	"${MXDB}" )
	    nodebugger="false"
	    echo "${MXDB} -p ${PROCID} ${IMAGEFILE} << END_OF_INPUT" > ${SCRIPT}
	    echo "walkback" >> ${SCRIPT}
	    echo "detach" >> ${SCRIPT}
	    echo "quit" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
        esac
	;;
    "SVR4_SCO" )
	case ${DEBUGGER} in
	"${DEBUG}" )
	    echo ""
	    echo "      NOTE:   Executable must be on local drive."
	    echo ""
	    nodebugger="false"
	    echo "${DEBUG}  -i c /proc/${PROCID} << END_OF_INPUT" > ${SCRIPT}
	    echo "t" >> ${SCRIPT}
	    echo "q" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
        esac
	;;
    "SVR4_SOL" )
	case ${DEBUGGER} in
	"${ADB}" )
	    echo ""
	    echo "      NOTE:   You must be root to get a valid trace."
	    echo ""
	    nodebugger="false"
	    echo "${ADB} ${IMAGEFILE} << END_OF_INPUT" > ${SCRIPT}
	    echo "0t${PROCID}:A" >> ${SCRIPT}
	    echo "\\\$c" >> ${SCRIPT}
	    echo ":R" >> ${SCRIPT}
	    echo "\\\$q" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
        esac
	;;
    "Linux" )
	case ${DEBUGGER} in
	"${GDB}" )
	    nodebugger="false"
	    echo "${GDB} << END_OF_INPUT" > ${SCRIPT}
	    echo "attach ${PROCID}" >> ${SCRIPT}
	    echo "bt" >> ${SCRIPT}
	    echo "detach" >> ${SCRIPT}
	    echo "END_OF_INPUT" >> ${SCRIPT}
	    ;;
        esac
	;;
    esac

    if [ x"${nodebugger}" = x"true" ]
    then
	rm -f ${SCRIPT}
	echo "ERROR: Don't know how to attach to a running process with "
	echo "'${DEBUGGER}' debugger on '${MACHINE}' machine."
    else
	#
	# Run the script.
	#
	echo "Debugger commands:"
	echo ""
	cat ${SCRIPT}
	echo ""
	echo "Stack trace:"
	echo ""
	sh ${SCRIPT} | tee ${SCRIPT}.tmp
	echo ""
	echo ${BDELIMITER}
	rm -f ${SCRIPT}
    fi

    ) >> ${DEBUGLOG} 2>&1

    if [ x"${ACTION}" = x"test" ]
    then
	result=1
	if [ -f ${SCRIPT}.tmp ]
	then
	    grep "main" ${SCRIPT}.tmp > /dev/null
	    result=$?
	    rm -f ${SCRIPT}.tmp
	fi

	if [ ${result} = 0 ]
	then
	    echo "Debugger ${DEBUGGER} test #${TESTNUM} SUCCEEDED"
	else
	    echo "Debugger ${DEBUGGER} test #${TESTNUM} FAILED"
	fi
    fi
}

do_the_grep ()
{
    PROCID="$1"
    running="$2"

    if [ x"$OPSYS" = x"unix_v5" ]
    then
	if [ x"$MACHINE" = x"Tru64" ]
	then
    	    ps w | grep ${PROCID} | grep ${PROEXE} > /dev/null
	else
    	    ps -deaf | grep ${PROCID} | grep ${PROEXE} > /dev/null
	fi
    	running=$?
    else
    	ps -axw | grep ${PROCID}  | grep ${PROEXE} > /dev/null
    	running=$?
    fi
}

test_case1 ()
{
    DEBUGGER=$1

    echo ${SDELIMITER}
    TESTNUM=1
    DEBUGLOG="`basename ${DEBUGGER}`${TESTNUM}.out"

    #
    # Create a core dump from ${PROEXE}.  This is done by sending
    # a SIGQUIT signal with no handler routine.
    #
    echo ""
    echo "Output from test #${TESTNUM} using ${DEBUGGER} debugger..."
    echo "Attempting to produce a stack trace from the 'core' file "
    echo "created by running 'crashtst.p'..."
    echo ""
    if [ -f coredb.db ]
    then
	echo y | prodel coredb > /dev/null
    fi
    prodb coredb demo > /dev/null
    pro -z1 coredb -b -p crashtst.p  > /dev/null
    echo ""

    #
    # Wait a reasonable amount of time for the process to start up.
    #
    count=1
    while [ ! -s core ] && [ $count -lt 5 ]
    do
	sleep ${SLEEPTIME}
	count=`expr $count + 1`
    done

    if [ -s core ]
    then
    	read_stack ${DEBUGGER} ${TESTNUM}
    else
        echo "core file not created as a result of crashtst.p" 
	echo ""
	echo "Debugger ${DEBUGGER} test #${TESTNUM} FAILED"
    fi
    #
    # cleanup
    #
    echo y | prodel coredb	> /dev/null # Cleanup
    echo
    rm -f core*
}

test_case2 ()
{
    DEBUGGER=$1
    PROCID=$2

    #
    # verify that it is possible to attach to a running process.
    #
    echo ${SDELIMITER}
    TESTNUM=2
    DEBUGLOG="`basename ${DEBUGGER}`${TESTNUM}.out"
    echo ""
    echo "Output from test #${TESTNUM} using ${DEBUGGER} debugger..."
    echo "Attempting to produce a stack trace by attaching to a looping process..."
    echo ""

    attach_stack ${DEBUGGER} ${PROCID} ${TESTNUM}
    echo ""
}

test_case3 ()
{
    DEBUGGER=$1
    PROCID=$2
    
    #
    # verify that progress will create a core file upon receiving
    # a "kill -8" signal.
    #
    echo ${SDELIMITER}
    TESTNUM=3
    DEBUGLOG="`basename ${DEBUGGER}`${TESTNUM}.out"
    echo ""
    echo "Output from test #${TESTNUM} using ${DEBUGGER} debugger:"
    echo "Attempting to produce a stack trace from the 'core' file "
    echo "created by 'kill -8' command..."
    echo ""
    
    #
    # Cause the looping process to dump core by sending a "kill -8"
    #
    sleep ${SLEEPTIME}
    kill -8 ${PROCID}
    count=1
    exists=0
    while [ $count -lt 5 ] && [ $exists -eq 0 ]
    do
    	# allow time for core file creation
    	sleep ${SLEEPTIME}
	do_the_grep "${PROCID}" "$running"
	if [ -s core ] && [ $running = 1 ]
	then
	    exists=1
	    continue
	else
	    count=`expr $count + 1`
	fi
    done
    echo ""
    
    if [ -s core ]
    then
    	read_stack ${DEBUGGER} ${TESTNUM}
    	rm -f core*
    else
    	echo "core file not created as a result of kill -8 command" 
	echo ""
	echo "Debugger ${DEBUGGER} test #${TESTNUM} FAILED"
    fi
}

start_looping ()
{
    #
    # start progress up as a looping background process, get it's process
    # id, kill it with core.
    #
    pro -b -p looping.p > /dev/null &
    PROCID=$!

    #
    # Wait a reasonable amount of time for the process to start up.
    #
    running=1
    count=1
    while [ $running -eq 1 ] && [ $count -lt 5 ]
    do
	sleep ${SLEEPTIME}
	do_the_grep "${PROCID}" "$running"
	count=`expr $count + 1`
    done
}

auto_cases ()
{
    DEBUGGER=$1

    test_case1 ${DEBUGGER}
    
    #
    # create "looping.p"
    #
    echo "repeat:" 		>> looping.p
    echo "    pause 1000." 	>> looping.p
    echo "end." 		>> looping.p
    
    start_looping

    if [ $running -eq 0 ]
    then
	test_case2 ${DEBUGGER} ${PROCID}
	#
	# Make sure the process is still running
	#
	do_the_grep "${PROCID}" "$running"
	if [ $running -eq 1 ]
	then
	    echo "WARNING: Attached process was killed"
	    start_looping
	fi
	if [ $running -eq 0 ]
	then
	    test_case3 ${DEBUGGER} ${PROCID}
	else
	    echo "FAILED: Could not start looping process."
    	    echo "Could not run ${DEBUGGER} #3"
	fi
    else
	echo "FAILED: Could not start looping process."
    	echo "Could not run ${DEBUGGER} test #2 and #3"
    fi

}

manual_cases ()
{
    DEBUGGER=$1

    if [ x"${ACTION}" = "xattach" ]
    then
	attach_stack ${DEBUGGER} ${PROCID}
    else
	read_stack ${DEBUGGER}
    fi
}

test_debuggers ()
{
    #
    #  INPUT:	Variable of array of arguments where each argument is
    #		of the form "<debug1>:<debug2>" where
    #		    debug1  specifies the debugger name.
    #		    debug2  specifies the full path name of the debugger.
    #		
    DEBUGLIST="$*"

    found=0
    for DEBUGINFO
    in ${DEBUGLIST}
    do
	DEBUGNAME=`echo ${DEBUGINFO} | cut -f1 -d':'`
	FULLDEBUGNAME=`echo ${DEBUGINFO} | cut -f2 -d':'`
	echo ""
	echo ${BDELIMITER}
	echo ""
	if [ -x ${FULLDEBUGNAME} ]
	then
	    found=1
	    echo "Using the ${DEBUGNAME} debugger to produce a stack trace from"
	    echo "image file:" 
	    echo "	${IMAGEFILE} "
	    echo "and core file:"
	    echo "	${CORE}"
	    if [ x"$ACTION" = x"test" ]
	    then
		auto_cases ${FULLDEBUGNAME}
	    else
		manual_cases ${FULLDEBUGNAME}
	    fi
	else
	    echo "${DEBUGNAME} ${DEBUGERROR}"
	fi
	echo ""
	echo ${BDELIMITER}
	echo ""
    done
    if [ "${found}" = "0" ]
    then
	echo ${NODEBUGGER}
	exit 1
    fi
}

svr4_menu ()
{
    svr4ans=n
    while [ x"${svr4ans}" != x"y" ]
    do
      echo ""
      echo ${BDELIMITER}
      echo "
        'uname -a' for your machine indicates:  ${INFO}

        Select the option which best describes your SVR4 machine:

         1.  DG/UX Intel
         2.  SCO UnixWare
	 3.  SCO Open Server 5

        99.  exit
      "
      echo $N "Option: " $C
      read option

      case ${option} in
        "1" )
        MACHINE="SVR4_DGUX"
        ;;
        "2" )
        MACHINE="SVR4_SCO"
        ;;
        "3" )
	MACHINE="SCO"
	;;
        "99" )
        exit
        ;;
        * )
        echo "UNKNOWN $MACHINE type"
        ;;
      esac
  echo $N "You selected '${MACHINE}' to describe your system. " $C
  echo $N "Is this correct (y/n)? " $C
  read svr4ans
    done
    export MACHINE
}

#
# MAIN:  Test each debugger by $MACHINE.
#
answer=n
while [ x"${answer}" != x"y" ]
do
  INFO=`uname -a`
  echo ""
  echo ${BDELIMITER}
  echo "
	'uname -a' for your machine indicates:  ${INFO}

	Select the option which best describes your UNIX machine:

	 1.  Tru64:     Compaq Tru64 
	 2.  AIX:       IBM RS6000
	 3.  HPUX:      Hewlett Packard
         4.  Sun:       Solaris Intel
	 5.  SunOS:     Sparc Solaris
	 6.  UnixV4:    UnixWare, SCO OS5, or DG/UX Intel
	 7.  Linux:     Any Linux 

	99.  exit
  "
  echo $N "Option: " $C
  read option

  case ${option} in
    "1" )
	MACHINE="Tru64"
	;;
    "2" )
	MACHINE="AIX"
	;;
    "3" )
	MACHINE="HPUX"
	;;
    "4" )
        MACHINE="SVR4_SOL"
        ;;
    "5" )
	MACHINE="SunOS"
	;;
    "6" )
	svr4_menu
	break
	;;
    "7" )
	MACHINE="Linux"
	;;
    "99" )
	exit
	;;
    * )
	echo "UNKNOWN $MACHINE type"
	;;
  esac
  echo $N "You selected '${MACHINE}' to describe your system. " $C
  echo $N "Is this correct (y/n)? " $C
  read answer

done

echo ""
echo ${BDELIMITER}
echo ""

case ${MACHINE} in
    "Tru64" )
	DBX="`type dbx | cut -f3 -d' '`"
	echo "
		The following debuggers are available through the
		'DEC OSF/1 Operating System' (OSFBASExxx) software subset:
			${DBX}
     	"
	test_debuggers "${ODBX}:${DBX}"
	;;
    "AIX" )
	DBX="`which dbx`"
	ADB="`which adb`"
	echo "
		The following debuggers are available through the
		'Base Application Development Toolkit' (bosadt.bosadt.obj)
		software package:
			${ADB}
			${DBX}
	"
	test_debuggers "${OADB}:${ADB}" "${ODBX}:${DBX}"
	;;
    "HPUX" )
	ADB="`type adb | cut -f3 -d' '`"
	XDB="`type xdb | cut -f3 -d' '`"
	echo "
		The following debuggers are available through the
		'Minimum HP-UX Commands / Recommended System Core'
		(OS-CORE) software package:
			${ADB}

		The following debuggers are available through the
		'Symbolic Debuggers / Programming Languages' 
		(PROG-LANGUAGES) software package:
			${XDB}
	"
	test_debuggers "${OADB}:${ADB}" "${OXDB}:${XDB}"
	;;
    "SCO" )
	ADB="`type adb | cut -f3 -d' '`"
	DBXTRA="`type dbxtra | cut -f3 -d' '`"
	echo "
		The following debuggers are available through the
		'SCO UNIX Development System Maintenance Supplement' 
		(soft) software package:
			${ADB}
			${DBXTRA}
	"
	test_debuggers "${OADB}:${ADB}" "${ODBXTRA}:${DBXTRA}"
	;;
    "SunOS" )
	ADB="`type adb | cut -f3 -d' '`"
	DBX="`type dbx | cut -f3 -d' '`"
	echo "
		The following debuggers are available through the
		'Programming Tools' (SUNWtoo) software package:
			${ADB}
		The following debuggers are available through the
		'SPARC works program development tools' (SPROsw) software package:
			${DBX}
	"
	test_debuggers "${OADB}:${ADB}" "${ODBX}:${DBX}"
	;;
    "SVR4_DGUX" )
	DBX="`type dbx | cut -f3 -d' '`"
	MXDB="`type mxdb | cut -f3 -d' '`"
	echo "
		The following debuggers are available through the
		'DG/UX Software Development Kit' (sdk) software package:
			${DBX}
			${MXDB}
	"
	test_debuggers "${OSDB}:${DBX}" "${OSDB}:${MXDB}"
	;;
    "SVR4_SCO" )
	DEBUG="`type debug | cut -f3 -d' '`"
	CORE=${CORE}.[0-9]*
	echo "
		The following debuggers are available through the
		'Enhanced Debugger' (edebug) software package:
			${DEBUG}
	"
	test_debuggers "${OSDB}:${DEBUG}"
	;;
    "SVR4_SOL" )
	ADB="`type adb | cut -f3 -d' '`"
	echo "
		The following debuggers are available through the
		'Programming Tools' (SUNWtoo) software package:
			${ADB}
	"
	test_debuggers "${OADB}:${ADB}" 
	;;
    "Linux" )
	GDB="`which gdb`"
	echo "
		The following debuggers are available through
		Linux:
			${GDB}
	"
	test_debuggers "${OGDB}:${GDB}"
	;;
    * )
	echo "UNKNOWN $MACHINE type"
	;;
esac

echo ""
echo ${BDELIMITER}
echo ""
